<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>OS课堂笔记</title>
      <link href="june/2022-5-4-OS%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0/"/>
      <url>june/2022-5-4-OS%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="OS课堂笔记"><a href="#OS课堂笔记" class="headerlink" title="OS课堂笔记"></a>OS课堂笔记</h1><h2 id="3-2"><a href="#3-2" class="headerlink" title="3/2"></a>3/2</h2><p><code>rm fs.img</code>：删除fs.img文件</p><p><code>$ make fs.img</code></p><p>若是最新，则回报：<code>make: “fs.img”已是最新。</code></p><p>非最新，则回报：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">./mkfs fs.img README _cat _echo _forktest _grep _init _kill _ln _ls _mkdir _rm _sh _stressfs _usertests _wc _zombie   <span class="comment">//./mkfs：执行mkfs文件；fs.img：输出的文件名；fs.img后面是所有要打包的文件的文件名，注意有些文件名前有下划线，有些没有（如README）。</span></span><br><span class="line">nmeta <span class="number">59</span> (boot, super, <span class="built_in">log</span> blocks <span class="number">30</span> inode blocks <span class="number">26</span>, bitmap blocks <span class="number">1</span>) blocks <span class="number">941</span> total <span class="number">1000</span>  <span class="comment">//boot block占1，super block占1，log（日志块）占30，inode blocks（i结点块）占26，bitmap block占1，1+1+30+26+1=59，59+941=1000 </span></span><br><span class="line">balloc: first <span class="number">666</span> blocks have been allocated <span class="comment">//前666个blocks（块）还没有分配。</span></span><br><span class="line">balloc: write bitmap block at sector <span class="number">58</span>  <span class="comment">//bitmap block(位映射块)放在扇区58（从0开始，0:boot block，1:super block，2~31:log，32~57:inode block，58:bitmap block）</span></span><br></pre></td></tr></table></figure><p><strong>在fs.img中打包一个新文件进去</strong>：<br>修改Makefile第185-186行，将新文件名添加在末尾（或$(UPROGS)前面）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">185</span> fs.img: mkfs README $(UPROGS) new_file.txt</span><br><span class="line"><span class="number">186</span>         ./mkfs fs.img README new_file.txt $(UPROGS) </span><br></pre></td></tr></table></figure><p>然后执行<br><code>make clean</code><br><code>make qemu-nox</code>：生成可执行的系统（只<code>make</code>的话是生成xv6）<br>可以看见<code>./mkfs fs.img README _cat _echo _forktest _grep _init _kill _ln _ls _mkdir _rm _sh _stressfs _usertests _wc _zombie  new_file.txt </code>，其末尾增加了new_file.txt</p><p>在虚拟机中<code>ls</code>，也可以看见新增了new_file.txt，输入<code>cat new_file.txt</code>可以查看其中内容。</p><h3 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h3><p>一个文件最大有140块（12个直接块，128个间接块），最大为71680字节。</p><p><code>fs.h</code>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NDIRECT 12  <span class="comment">//一个文件有12个直接块</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NINDIRECT (BSIZE / sizeof(uint))  <span class="comment">//间接块数量=512/4(每个条目占4字节)=128块</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXFILE (NDIRECT + NINDIRECT)     <span class="comment">//一个文件最多有多少块</span></span></span><br><span class="line"><span class="comment">// 一个文件最大大小=最多块数*块的大小=(12+128)*512=71680字节(Byte)</span></span><br></pre></td></tr></table></figure><blockquote><p>1Byte = 8bit</p></blockquote><p>一个文件系统必有i结点，存储索引信息等。</p><h4 id="术语："><a href="#术语：" class="headerlink" title="术语："></a>术语：</h4><ol><li>data block <strong>数据块</strong><br>用来放置文件内容。</li><li>super block <strong>超级块</strong><br>主要记录文件系统的整体信息。</li><li>inode <strong>索引节点</strong>（i节点）<br>主要记录文件的属性、权限以及该文件实际数据的位置（所在block号）。<ul><li>inode的大小固定，一个文件占用一个inode。</li><li>文件系统能创建的文件数量与inode的数量相关。</li></ul></li><li>bitmap <strong>映射表/对照表</strong><ol><li>block bitmap：区块对照表<br>记录使用与未使用的block号，并在文件添加修改时对应地修改block的使用状况。</li><li>inode bitmap：inode对照表<br>记录使用与未使用的inode号，并在文件添加修改时对应地修改inode的使用状况</li></ol></li></ol><h4 id="磁盘组成："><a href="#磁盘组成：" class="headerlink" title="磁盘组成："></a>磁盘组成：</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Disk layout:</span><br><span class="line">[ boot block | sb block | <span class="built_in">log</span> | inode blocks | <span class="built_in">free</span> bit <span class="built_in">map</span> | data blocks ]</span><br></pre></td></tr></table></figure><h4 id="查看fs-img"><a href="#查看fs-img" class="headerlink" title="查看fs.img"></a>查看fs.img</h4><p>执行<br><code>vim fs.img</code> 打开fs.img<br><code>:%!xxd</code> 用二进制查看</p><ul><li>boot块：第1~32行，即<code>00000000</code>~<code>000001f0</code></li><li>super块：第32-行，即<code>00000200</code>~<code>000002f0</code></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">33 00000200: e803 0000 ad03 0000 c800 0000 1e00 0000  ................</span><br></pre></td></tr></table></figure><p><code>e802 0000</code>：(3E8)<del>16</del> = (1000)<del>10</del> ，表示文件系统的大小（总块数）；<br><code>ad03 0000</code>：(3AD)<del>16</del> = (941)<del>10</del> ，表示data block的数量；<br><code>c800 0000</code>：(C8)<del>16</del> = (200)<del>10</del> ，表示inode的数量；<br><code>1e00 0000</code>：(1E)<del>16</del> = (30)<del>10</del> ，表示log block的数量。</p><h3 id="mkfs-c的tagbar"><a href="#mkfs-c的tagbar" class="headerlink" title="mkfs.c的tagbar"></a>mkfs.c的tagbar</h3><h4 id="变量variables"><a href="#变量variables" class="headerlink" title="变量variables"></a>变量variables</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">nbitmap</span><br><span class="line">ninodeblocks</span><br><span class="line">nlog</span><br><span class="line">nmeta <span class="comment">//元块，boot block，sb block，log，inode blocks和free bitmap的总块数</span></span><br><span class="line">nblocks <span class="comment">//data blocks的块数 nmeta+nblocks=整个盘片所有的块数</span></span><br><span class="line">fsfd</span><br><span class="line">sb <span class="comment">//超级块</span></span><br><span class="line">zeroes</span><br><span class="line">freeinode </span><br><span class="line">freeblock</span><br></pre></td></tr></table></figure><h4 id="函数functions"><a href="#函数functions" class="headerlink" title="函数functions"></a>函数functions</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">xshort(ushort x)</span><br><span class="line">xint(uint x)</span><br><span class="line">main(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span><br><span class="line">balloc(<span class="keyword">int</span> used)<span class="comment">//分配一个块</span></span><br><span class="line">wsect(uint sec, <span class="keyword">void</span> *buf)<span class="comment">//写一个块</span></span><br><span class="line">rsect(uint sec, <span class="keyword">void</span> *buf)<span class="comment">//读一个块</span></span><br><span class="line">winode(uint inum, struct dinode *ip) <span class="comment">//写一个inode</span></span><br><span class="line">rinode(uint inum, struct dinode *ip) <span class="comment">//读一个inode</span></span><br><span class="line">ialloc(ushort type)<span class="comment">//分配i节点</span></span><br><span class="line">iappend(uint inum, <span class="keyword">void</span> *xp, <span class="keyword">int</span> n)<span class="comment">//追加i节点</span></span><br></pre></td></tr></table></figure><p><code>mkfs.c &gt; main()</code>中：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">bzero(&amp;de, <span class="keyword">sizeof</span>(de)); </span><br><span class="line">de.inum = xshort(rootino);  </span><br><span class="line"><span class="built_in">strcpy</span>(de.name, <span class="string">&quot;.&quot;</span>); </span><br><span class="line">iappend(rootino, &amp;de, <span class="keyword">sizeof</span>(de));  </span><br><span class="line"></span><br><span class="line">bzero(&amp;de, <span class="keyword">sizeof</span>(de));</span><br><span class="line">de.inum = xshort(rootino);</span><br><span class="line"><span class="built_in">strcpy</span>(de.name, <span class="string">&quot;..&quot;</span>);  </span><br><span class="line">iappend(rootino, &amp;de, <span class="keyword">sizeof</span>(de));</span><br></pre></td></tr></table></figure><p>往根目录下追加了两个目录项“.”和“..”，他们都指向根目录。<code>cd .</code>和<code>cd ..</code>都只会跳到根目录。<br>即<code>ls</code>命令后出现的前两行，大小都是512（占一个块）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">.              1 1 512</span><br><span class="line">..             1 1 512</span><br><span class="line">README         2 2 2286</span><br><span class="line">cat            2 3 16256</span><br><span class="line">echo           2 4 15112</span><br><span class="line">forktest       2 5 9420</span><br><span class="line">grep           2 6 18476</span><br><span class="line">init           2 7 15696</span><br><span class="line">kill           2 8 15144</span><br><span class="line">ln             2 9 14996</span><br><span class="line">ls             2 10 17624</span><br><span class="line">mkdir          2 11 15240</span><br><span class="line">rm             2 12 15216</span><br><span class="line">sh             2 13 27860</span><br><span class="line">stressfs       2 14 16132</span><br><span class="line">usertests      2 15 67236</span><br><span class="line">wc             2 16 16996</span><br><span class="line">zombie         2 17 14808</span><br><span class="line">new_file.txt   2 18 23</span><br><span class="line">console        3 19 0</span><br></pre></td></tr></table></figure><h3 id="Makefile-gt-xv6-pdf"><a href="#Makefile-gt-xv6-pdf" class="headerlink" title="Makefile &gt; xv6.pdf"></a>Makefile &gt; xv6.pdf</h3><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">xv6.pdf:</span> <span class="string">$(PRINT)</span></span><br><span class="line"><span class="string">./runoff</span></span><br><span class="line"><span class="string">ls</span> <span class="string">-l</span> <span class="string">xv6.pdf</span></span><br><span class="line"></span><br><span class="line"><span class="attr">print:</span> <span class="string">xv6.pdf</span></span><br></pre></td></tr></table></figure><p>执行<code>make xv6.pdf</code>，如果没错会生成一个<code>xv6.pdf</code></p><h2 id="4-9"><a href="#4-9" class="headerlink" title="4/9"></a>4/9</h2><h3 id="可执行文件"><a href="#可执行文件" class="headerlink" title="可执行文件"></a>可执行文件</h3><p><code>ls _*</code>可以看到所有首位是下划线的文件，这些文件是<strong>可执行文件</strong>。在系统中不显示下划线。</p><p><code>file</code>查看它们的属性可知是32位的程序，Intel 80386，静态链接的（statically linked）。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ file _cat</span><br><span class="line">_cat: ELF <span class="number">32</span>-bit LSB executable, Intel <span class="number">80386</span>, version <span class="number">1</span> (SYSV), statically linked, with debug_info, <span class="keyword">not</span> stripped</span><br></pre></td></tr></table></figure><p><code>_xxx</code>通常编译自<code>xxx.c</code>。</p><p><code>cat.c</code>的头文件有：</p><ul><li>types.h：给类型取别名。</li><li>stat.h：用编号定义目录、文件、设备和一个状态结构体stat。</li><li>user.h：系统调用和类似c语言标准库中的函数ulib.c</li></ul><p>启动一个进程时会隐形地打开3个文件：</p><ul><li>0号：标准输入文件</li><li>1号：标准输出文件，</li><li>2号：标准错误输出文件</li></ul><p>执行<code>cat</code>时若不带参数则以键盘的输入为参数，输出输入的内容（按<code>CTRL+D</code>退出）；带参数则输入参数中的内容。</p><h4 id="下划线的规定"><a href="#下划线的规定" class="headerlink" title="下划线的规定"></a>下划线的规定</h4><p><code>Makefile</code>：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 所有带下划线的可执行文件依赖于不带下划线的.o文件与用户库文件</span></span><br><span class="line"><span class="string">_%:</span> <span class="string">%.o</span> <span class="string">$(ULIB)</span></span><br><span class="line"><span class="string">$(LD)</span> <span class="string">$(LDFLAGS)</span> <span class="string">-N</span> <span class="string">-e</span> <span class="string">main</span> <span class="string">-Ttext</span> <span class="number">0</span> <span class="string">-o</span> <span class="string">$@</span> <span class="string">$^</span></span><br><span class="line"><span class="string">$(OBJDUMP)</span> <span class="string">-S</span> <span class="string">$@</span> <span class="string">&gt;</span> <span class="string">$*.asm</span></span><br><span class="line"><span class="string">$(OBJDUMP)</span> <span class="string">-t</span> <span class="string">$@</span> <span class="string">|</span> <span class="string">sed</span> <span class="string">&#x27;1,/SYMBOL TABLE/d; s/ .* / /; /^$$/d&#x27;</span> <span class="string">&gt;</span> <span class="string">$*.sym</span></span><br></pre></td></tr></table></figure><h4 id="系统自带的可执行文件"><a href="#系统自带的可执行文件" class="headerlink" title="系统自带的可执行文件"></a>系统自带的可执行文件</h4><ul><li><p>cat</p></li><li><p>echo：将参数标准输出（STDOUT），即在显示器上输出。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ echo hello</span><br><span class="line">hello</span><br><span class="line">$ echo 重复这句话</span><br><span class="line">重复这句话</span><br></pre></td></tr></table></figure></li><li><p>ln</p></li><li><p>ls</p></li><li><p>mkdir：创建目录</p></li><li><p>rm：删除文件</p></li><li><p>forktest：创建子进程</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ forktest</span><br><span class="line">fork test</span><br><span class="line">fork test OK</span><br></pre></td></tr></table></figure></li><li></li></ul><h3 id="打包程序至系统"><a href="#打包程序至系统" class="headerlink" title="打包程序至系统"></a>打包程序至系统</h3><ol><li><p>写一个可执行的.c文件（以<code>hello.c</code>为例），注意头文件和系统自带函数。</p></li><li><p>在Makefile的UPROGS中添加文件名，fs.img打包时就会打包进去。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">UPROGS&#x3D;\</span><br><span class="line">     _cat\</span><br><span class="line">     _echo\</span><br><span class="line">     _hello\   ←添加的文件</span><br></pre></td></tr></table></figure></li><li><p><code>make clean</code>，<code>make</code></p></li><li><p><code>make qemu-nox</code>可以看到可执行文件<code>hello</code>出现在了根目录下。</p></li><li><p>执行<code>hello</code>可以正常运行。</p></li></ol><h3 id="写一个copy"><a href="#写一个copy" class="headerlink" title="写一个copy"></a>写一个copy</h3><h3 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h3><p>1.创建GDB文件</p><p><code>make gdbinit</code>生成一个.gdbinit脚本文件，它配置了启动gdb时的端口信息。</p><p>2.在无图形化界面下启动gdb</p><p><code>make gdb-nox-gdb</code></p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统实验 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>嵌入式应用笔记</title>
      <link href="june/2022-4-1-%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%AC%94%E8%AE%B0/"/>
      <url>june/2022-4-1-%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="3-4"><a href="#3-4" class="headerlink" title="3/4"></a>3/4</h2><p><strong>1.用直白的话,概述下列的函数的实现过程,并重点解释temp = (c&gt;&gt;j) &amp; 0x01;gpio_set (led_d[j], temp);的作用.</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LEDshow1</span><span class="params">(uint_8 i, uint_8 c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  uint_8 temp;</span><br><span class="line">  uint_8 j;</span><br><span class="line">  <span class="comment">//位选全部置0=不选中</span></span><br><span class="line">  <span class="keyword">for</span> (j=<span class="number">0</span>;j&lt;=<span class="number">3</span>;j++)</span><br><span class="line">  gpio_set (led_cs[j], <span class="number">0</span>);</span><br><span class="line">  <span class="comment">//数据上线</span></span><br><span class="line">  <span class="keyword">for</span> (j=<span class="number">0</span>;j&lt;=<span class="number">7</span>;j++)</span><br><span class="line">  &#123;</span><br><span class="line">  temp = (c&gt;&gt;j) &amp; <span class="number">0x01</span>;  <span class="comment">//</span></span><br><span class="line">  gpio_set (led_d[j], temp);</span><br><span class="line">   &#125;</span><br><span class="line">  <span class="comment">//选择的位选置1</span></span><br><span class="line">  gpio_set (led_cs[i], <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>答：为了方便叙说，位号指4位LED的某位，引脚号指数据线的8位的某个引脚。<br>直白叙述：<br>（1）先通过第一个循环，将每个位置为0，即LED的每一位都不选中，<br>（2）接着通过第二个循环，是将数据线的每个引脚设置相应的数据，具体是通过temp = (c&gt;&gt;j) &amp; 0x01的c&gt;&gt;j先将j位的移至最后位，再与0x01相与，j位的值给temp(准确地是temp的最后一位，其他位无意义)，接着通过gpio_set (led_d[j], temp)，由temp给led_d[j]，即实现将c的j位值给了led_d[j]对应的引脚，如此循环8次，数据线8位得到相应数值。<br>（3）最后通过gpio_set (led_cs[i], 1)将LED位号i的相应数字显示。</p><br><p><strong>2.问一次调用LEDshow(uint_8 data[4]),显示LED的4位的几位？</strong></p><p>答：一次调用LEDshow，显示LED的某1位。</p><h2 id="3-11"><a href="#3-11" class="headerlink" title="3/11"></a>3/11</h2><p><strong>1、Flash的写、擦除的操作是怎样？</strong><br>答：1.（1）擦除的操作：将存储单元的二进制内容由0变1；（2）写的操作：将存储单元的二进制内容由1变0</p><br><p><strong>2、写出下列所指地址，并说出此地址是什么地方，作用是干什么的？</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 设置目标地址</span></span><br><span class="line">FTFA_FCCOB1 = <span class="number">0x00</span>;</span><br><span class="line">FTFA_FCCOB2 = <span class="number">0x04</span>;</span><br><span class="line">FTFA_FCCOB3 = <span class="number">0x0C</span>;</span><br></pre></td></tr></table></figure><p>答：地址：0x00040c，该地址为Flash加密寄存器，作用是将加密数据或不加密数据写入该地址，完成加密或不加密操作。</p><br><p><strong>3、Flash读的流程图</strong><br>答：逻辑地址读和物理地址读的两个流程图</p><p><img src="E:\学习\大三下\嵌入式应用\QQ图片20220318102504.jpg" alt="读的流程图"></p><br><p><strong>4.Flash写的流程图</strong></p><p><img src="E:\学习\大三下\嵌入式应用\QQ图片20220318102512.jpg" alt="写的流程图"></p><br><p><strong>5.擦除的流程图</strong></p><p><img src="E:\学习\大三下\嵌入式应用\QQ图片20220318102516.jpg" alt="擦除的流程图"></p><br><p><strong>6.区域保护的流程图</strong></p><p><img src="E:\学习\大三下\嵌入式应用\QQ图片20220318102521.jpg" alt="区域保护"></p><br><h2 id="3-18"><a href="#3-18" class="headerlink" title="3/18"></a>3/18</h2><p><strong>1、什么是ADC模块，其作用又是什么？</strong></p><p>ADC模块：模/数转换模块，又可以称作AD转换模块；功能是将电压信号转换为相应的数字信号。</p><br><p><strong>2、与AD转换编程直接相关的基本问题有哪些？</strong></p><p>转换精度、转换速度、单端输入与差分输入、AD参考电压、滤波问题、物理量回归。</p><br><p><strong>3、理论上，KL25中有多少个模拟输入通道？芯片内部包含一个温度传感器，其通道号是多少?</strong></p><p>26个。</p><p>温度传感器通道号：26。</p><br><p><strong>4、数据结果寄存器在不同的模式下数据表达情况，其中有多位符号位，如何理解？举例说明。</strong></p><p>数据有效位只有4位，前面可以视作只有1位符号，也可视作有多位符号。</p><br><p><strong>5、DA转换器一般由哪些部分组成的？</strong></p><p>DA转换器一般由数码缓冲寄存器、模拟电子开关、参考电压、解码网络和求和电路等组成。</p><br><p><strong>6、在本书选用的KL25封装中，DA模块多少个对外引脚？</strong></p><p>1个对外引脚，PTE30。</p><br><p><strong>7、画出adc_read的编程流程图。</strong></p><br><p><strong>8、计算</strong></p><p><strong>(1)  B=0xFC;A=0b00000100 | B;那么 A=?</strong></p><p><strong>(2)  B=0xAD;A=0b00000100 &amp; B;那么 A=?</strong></p><p><strong>(3)  A=0x33;A |= 0x01;A=?</strong></p><p><strong>(4)  A=0xAD;A &amp;= ~0x01;A=?</strong> </p><p>（1）A=0xFC</p><p>（2）A=0x04</p><p>（3）A=0x33</p><p>（4）A=0xAC</p><br><h2 id="3-25"><a href="#3-25" class="headerlink" title="3/25"></a>3/25</h2><p><strong>1、SPI是异步还是同步的串行通信方式?</strong></p><p>SPI同步串行通讯。</p><br><p><strong>2、SPI可以作半双工还是全双工通信？</strong></p><p>全双工。</p><br><p><strong>3、MISO和MOSI分别是什么意思？</strong></p><p>MISO：主机输入/从机输出数据线。</p><p>MOSI：主机输出/从机输入数据线。</p><br><p><strong>4、SPI的SCK是谁提供的？并控制着谁的通信？</strong></p><p>SCK：串行时钟线。</p><p>串行时钟信号由主机的内部总线时钟分频获得，主机的SCK引脚输出给从机的SCK引脚，控制整个数据的传输速度。</p><br><p><strong>5、SPI有哪些常用波特率的值？</strong></p><p>可取12000、6000、4000、3000、1500、1000bps。</p><br><p><strong>6、SPI通信时有两个重要的参数CPOL和CPHA，由此获得几种通信时序？</strong></p><p>时钟极性由CPOL控制，时钟相位由CPHA来控制，二者组合起来共有四种可能的取值情况，具体如下：</p><p>（1）空闲电平低电平，上升沿取数（CPOL=0，CPHA=0）</p><p>（2）空闲电平低电平，下降沿取数（CPOL=0，CPHA=1）</p><p>（3）空闲电平高电平，下降沿取数（CPOL=1，CPHA=0）</p><p>（4）空闲电平高电平，上升沿取数（CPOL=1，CPHA=1）</p><br><p><strong>7、画一个CPOL=1和CPHA=0时的数据/时钟时序图。</strong></p><br><p><strong>8、画SPI_send1的流程图。</strong></p><br><p><strong>9、IIC是什么通信方式？</strong></p><p>IIC：集成电路互联总线，采用双向2线制串行数据传输方式。</p><br><p><strong>10、IIC主要用于哪里通信？</strong></p><p>主要用于同一电路板内各集成电路模块之间的连接</p><br><p><strong>11、IIC通信需要有几根线，是哪几种线？</strong></p><p>两根线：数据线、时钟线。</p><br><p><strong>12、IIC的寻址过程是怎么操作的？</strong> </p><p>I2C总线采用了独特的寻址约定，规定了起始信号后的第一个字节为寻址字节，用来寻址被控器件，并规定数据传送方向。<br>具体的寻址过程为：主控器发送起始信号后，立即发送寻址字节，这时总线上的所有器件都将寻址字节中的7位地址与自己器件地址比较。如果两者相同，则该器件认为被主控器寻址，并发送应答信号，被控器根据数据方向位确定自身是作为发送器还是接收器。</p><br><h2 id="4-1"><a href="#4-1" class="headerlink" title="4/1"></a>4/1</h2><p><strong>1、TSI模块是干什么用的？</strong></p><p>触摸感应输入模块TSI，可用于基于接近感应的人机交互设备的设计，实现操作人员与电气设备的隔离，避免了对设备的直接操作，也使得设备损坏的概率降低，从而减少了维护成本。</p><br><p><strong>2、TSI是通过什么方式识别触摸的？</strong></p><p>根据电子学的知识可知，未接地的电极与地之间存在电容。<br>人体可以当作是一个接地面，当有人体接近电极板时，等效地增大了电极与地之间的有效面积，使电极板电容值增大。</p><p>TSI模块的内部机制可以实现对电极电容值的检测，并且可以设定触发检测事件的阈值。当检测到电容值大于设定阈值时，TSI的触发标志位将置位，并可激活发出中断请求，从而实现了触摸感应事件的响应。</p><br><p><strong>3、TSI是通过什么方式测量电容大小的？</strong> </p><p>TSI模块内部具有两个电流源对外接电极进行充放电，在电极板上产生三角波信号，其频率随电极电容变化而变化，当电极电容增大时，三角波信号的频率减小，周期变大。<br>TSI模块以一个内部振荡器产生的时钟信号为参考节拍，对电极上的三角波电压信号的周期进行测量计数，当三角波电压信号周期增大时，对应计数值亦会增大。</p><br><p><strong>4、嵌入式实时操作系统是什么？</strong></p><p>嵌入式操作系统（Embedded Operation System，EOS）是一种工作在嵌入式计算机上的系统软件。一般情况下，它嵌入到微控制器（Microcontroller，MCU）、应用处理器（Application Processor）或其他存储载体中。<br>它有一般操作系统最基本的功能，负责嵌入式系统的软/硬件资源的分配、任务调度、同步机制、中断处理等功能。</p><br><p><strong>5、RTOS的基本结构包括哪些？</strong></p><p>从结构来看，一般情况下，RTOS内核表现为微内核（Micro Kernel）结构，将核心功能（如任务管理、任务调度、任务通信、中断处理）放在内核中，而将那些不是必需的功能和服务（如存储管理、设备管理、网络通信、文件系统等）作为内核之上可配置的部分。</p><br><p><strong>6、RTOS的基本功能有哪些？</strong></p><p>任务管理与调度、任务间的通信与同步、存储管理、时间管理、中断处理等。</p><br><p><strong>7、RTOS调度的基本单位是什么？它有那几种状态？</strong></p><p>RTOS调度的基本单位就是任务。</p><br><p><strong>8、MQX的任务间通信和同步主要机制包括哪些？</strong></p><p>MQX的任务间通信和同步主要机制有消息、事件、信号量等。</p><br><p><strong>9、整个系统的时间基准是什么？</strong></p><p>RTOS需要一个硬件定时器来产生需要的“滴答”中断，作为整个系统的时间基准，这个时间基准是系统调度的基础。滴答中断也是系统定时服务的基础，生成系统各种格式的时间。</p><br><p><strong>10、任务是什么？</strong></p><p>在RTOS下，系统把一个复杂的嵌入式应用工程按一定规则分解成一个个功能清晰的小工程，然后设定各个小工程的运行规则，交给RTOS管理，这就是基于RTOS编程的基本思想。这一个个的小工程被称之为任务（Task）。</p><br><p><strong>11、死锁产生的必要条件是哪些？</strong></p><p>死锁产生的必要条件有四个，即:<br>资源的互斥访问<br>资源的不可抢占<br>资源的请求保持<br>任务的循环等待</p><br><p><strong>12、任务间通信的方式主要有哪些？</strong> </p><p>任务间通信的方式主要有事件、信号量、消息等。</p><br><h2 id="Arduino用LED加7数码管译码器的程序。"><a href="#Arduino用LED加7数码管译码器的程序。" class="headerlink" title="Arduino用LED加7数码管译码器的程序。"></a>Arduino用LED加7数码管译码器的程序。</h2><p>大家先理解理解，以后作为作业让大家回答。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//数据编码c和位编码j的确定下,一位的显示</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LEDShow1</span><span class="params">(unsigned <span class="keyword">char</span> c,<span class="keyword">int</span> j)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> <span class="keyword">int</span> i;</span><br><span class="line"> <span class="keyword">if</span>(j&gt;<span class="number">3</span>) j=<span class="number">0</span>;<span class="comment">//位线是否越界</span></span><br><span class="line"> <span class="comment">//数据上线</span></span><br><span class="line"> <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)</span><br><span class="line"> &#123;</span><br><span class="line">  digitalWrite(LEDData[i],(c&gt;&gt;i)&amp;<span class="number">0x01</span>);<span class="comment">//c为所显示值;低4位为数据，高1位为小数点</span></span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">//位选线</span></span><br><span class="line"> <span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;<span class="number">2</span>;i++)</span><br><span class="line"> &#123;</span><br><span class="line">  digitalWrite(LEDCS[i], (j&gt;&gt;i)&amp;<span class="number">0x01</span>);<span class="comment">//2位;j为所选位</span></span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 嵌入式应用 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
