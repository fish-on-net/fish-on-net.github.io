<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>闲居庭</title>
  
  <subtitle>little garden</subtitle>
  <link href="https://fish-on-net.github.io/atom.xml" rel="self"/>
  
  <link href="https://fish-on-net.github.io/"/>
  <updated>2022-10-30T11:23:28.128Z</updated>
  <id>https://fish-on-net.github.io/</id>
  
  <author>
    <name>某不知名咸鱼</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>俗话说的好……</title>
    <link href="https://fish-on-net.github.io/june/2022-10-20-sad/"/>
    <id>https://fish-on-net.github.io/june/2022-10-20-sad/</id>
    <published>2022-10-19T16:00:00.000Z</published>
    <updated>2022-10-30T11:23:28.128Z</updated>
    
    <content type="html"><![CDATA[<p>书到用时方恨少！！！</p><p>梅关系，c语言我已经在现学了！临阵磨枪不快也光！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;书到用时方恨少！！！&lt;/p&gt;
&lt;p&gt;梅关系，c语言我已经在现学了！临阵磨枪不快也光！&lt;/p&gt;
</summary>
      
    
    
    
    <category term="杂记" scheme="https://fish-on-net.github.io/categories/%E6%9D%82%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>数据结构练习题1</title>
    <link href="https://fish-on-net.github.io/june/2022-8-30-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%BB%83%E4%B9%A0%E9%A2%981/"/>
    <id>https://fish-on-net.github.io/june/2022-8-30-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%BB%83%E4%B9%A0%E9%A2%981/</id>
    <published>2022-08-29T16:00:00.000Z</published>
    <updated>2022-10-30T11:23:53.613Z</updated>
    
    <content type="html"><![CDATA[<h2 id="线性表的顺序表示"><a href="#线性表的顺序表示" class="headerlink" title="线性表的顺序表示"></a>线性表的顺序表示</h2><p>1.从顺序表删除具有最小值的元素（假设唯一）并由函数返回被删元素的值，空出的位置由最后元素填补，若顺序表为空，则显示出错信息并退出运行。</p><span id="more"></span><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Del_Min</span><span class="params">(SqList &amp;L,ElemType $value)</span></span>&#123;</span><br><span class="line"><span class="comment">//删除顺序表L中最小值元素结点，并通过引用形参value返回其值</span></span><br><span class="line"><span class="comment">//若删除成功则返回true，否则返回false</span></span><br><span class="line"><span class="keyword">if</span>(L.length==<span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">//表空，中止操作返回</span></span><br><span class="line">value = L.data[<span class="number">0</span>];<span class="comment">//假定0号元素最小</span></span><br><span class="line"><span class="keyword">int</span> pos = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;L.length;i++)<span class="comment">//循环，寻找最小值元素</span></span><br><span class="line"><span class="keyword">if</span>(L.data[i] &lt; value)&#123;<span class="comment">//value记忆当前具有最小值的元素</span></span><br><span class="line">value = L.data[i];</span><br><span class="line">pos = i;</span><br><span class="line">&#125;</span><br><span class="line">L.data[pos] = L.data[L.length<span class="number">-1</span>];<span class="comment">//空出的位置由最后一个元素填补</span></span><br><span class="line">L.length--;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;<span class="comment">//此时value即为最小值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.设计一个高效算法，将顺序表L的所有元素逆置，要求算法的空间复杂度为O(1)。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Reverse</span><span class="params">(Sqlist &amp;L)</span></span>&#123;</span><br><span class="line">    ElemType temp;<span class="comment">//辅助变量</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;L.length/<span class="number">2</span>;i++)&#123; <span class="comment">//交换L.data[i]和L.data[L.length-i-1]</span></span><br><span class="line">        temp = L.data[i];</span><br><span class="line">        L.data[i] = L.data[L.length-i<span class="number">-1</span>];</span><br><span class="line">        L.data[L.length-i<span class="number">-1</span>] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3.对长度为n的顺序表L，编写一个时间复杂度为O(N)、空间复杂度为O(1)的算法，该算法删除线性表中所有值为x的数据元素.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//方法一</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Del1_x</span><span class="params">(Sqlist &amp;L,Elemtype x)</span></span>&#123;</span><br><span class="line"><span class="comment">//本算法实现删除顺序表L中所有值为x的数据元素</span></span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">0</span>,i;<span class="comment">//记录值不等于x的元素个数</span></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;L.length;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(L.data[i]!=x)&#123;</span><br><span class="line">            L.data[k]=L.data[i];</span><br><span class="line">            k++;<span class="comment">//不等于x的元素增1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    L.length = k;<span class="comment">//顺序表L的长度等于k</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//方法二</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Del2_x</span><span class="params">(Sqlist &amp;L,Elemtype x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> k=<span class="number">0</span>,i=<span class="number">0</span>;<span class="comment">//k记录值等于x的元素个数</span></span><br><span class="line">    <span class="keyword">while</span>(i&lt;L.length)&#123;</span><br><span class="line">        <span class="keyword">if</span>(L.data[i]==x)</span><br><span class="line">            k++;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            L.data[i-k] = L.data[i]; <span class="comment">//当前元素向前移k个位置</span></span><br><span class="line">        i++；</span><br><span class="line">    &#125;</span><br><span class="line">    L.length = L.length-k;<span class="comment">//顺序表L的长度递减</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4.从<strong>有序顺序表</strong>中删除其值在给定值s与t之间（要求s&lt;t）的所有元素，若s或t不合理或顺序表为空，则显示出错信息并退出运行.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//因为是有序表，所以删除的元素必然是相连的整体。</span></span><br><span class="line"><span class="comment">//先寻找值大于等于s的第一个元素（第一个删除的元素），然后寻找值大于t的第一个元素（最后一个删除的元素的下一个元素），要将这段元素删除，只需将后面的元素前移。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Del_s_t</span><span class="params">(Sqlist &amp;L,Elemtype s,Elemtype t)</span></span>&#123;</span><br><span class="line"><span class="comment">//删除有序顺序表L中值在s和t之间的所有元素</span></span><br><span class="line">    <span class="keyword">int</span> i,j;</span><br><span class="line">    <span class="keyword">if</span>(s&gt;=t||L.length==<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;L.length&amp;&amp;L.data[i]&lt;s;i++); <span class="comment">//寻找值大于等于s的第一个元素</span></span><br><span class="line">    <span class="keyword">if</span>(i&gt;=L.length)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">//所有元素值均小于s，返回</span></span><br><span class="line">    <span class="keyword">for</span>(j=i;j&lt;L.length&amp;&amp;L.data[j]&lt;=t;j++);<span class="comment">//寻找值大于t的第一个元素</span></span><br><span class="line">    <span class="keyword">for</span>(;j&lt;L.length;i++,j++)</span><br><span class="line">        L.data[i] = L.data[j];<span class="comment">//前移，填补被删元素位置</span></span><br><span class="line">    L.length = i；</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>5.从<strong>顺序表</strong>中删除其值在给定值s与t之间（要求s&lt;t）的所有元素，若s或t不合理或顺序表为空，则显示出错信息并退出运行.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Del_s_t</span><span class="params">(Sqlist &amp;L,Elemtype s,Elemtype t)</span></span>&#123;</span><br><span class="line"><span class="comment">//删除顺序表L中值在给定值s与t（要求s&lt;t）之间的所有元素</span></span><br><span class="line">    <span class="keyword">int</span> i,k=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(L.length==<span class="number">0</span>||s&gt;=t)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">//线性表为空或s、t不合法，返回</span></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;L.length;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(L.data[i]&gt;=s &amp;&amp; L.data[i]&lt;=t)</span><br><span class="line">            k++;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            L.data[i-k] = L.data[i]; <span class="comment">//当前元素前移K个位置</span></span><br><span class="line">    &#125;</span><br><span class="line">    L.length -= k;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>6.从有序顺序表中删除所有其值重复的元素，使表中所有元素的值均不同。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Delete_Same</span><span class="params">(Seqlist &amp;L)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(L.length == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">int</span> i,j;<span class="comment">//i存储第一各不相同的元素，j为工作指针</span></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0.</span>j=<span class="number">1</span>;j&lt;L.length;j++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(L.data[i]!=L.data[j])<span class="comment">//查找下一个与上个元素值不同地元素</span></span><br><span class="line">            L.data[++i]=L.data[j];<span class="comment">//找到后将元素前移</span></span><br><span class="line">    &#125;</span><br><span class="line">    L.length = i+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>7.<strong>将两个有序顺序表合并为一个新的有序顺序表，并由函数返回结果顺序表。</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Merge</span><span class="params">(Seqlist A,Seqlist B,Seqlist &amp;C)</span></span>&#123;</span><br><span class="line"><span class="comment">//将有序顺序表A与B合并为一个新的有序顺序表</span></span><br><span class="line">    <span class="keyword">if</span>(A.length+B.length&gt;C.MaxSize)<span class="comment">//大于顺序表的最大长度</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">0</span>;j=<span class="number">0</span>;k=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;A.length &amp;&amp; j&lt;B.length)&#123; <span class="comment">//循环，两两比较，小者存入结果表</span></span><br><span class="line">        <span class="keyword">if</span>(A.data[i]&lt;=B.data[j])</span><br><span class="line">            C.data[k++] = A.data[i++];</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            C.data[k++] = B.data[j++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;A.length)<span class="comment">//还剩一个没有比较完的顺序表</span></span><br><span class="line">        C.data[k++] = A.data[i++];</span><br><span class="line">    <span class="keyword">while</span>(j&lt;B.length)</span><br><span class="line">        C.data[k++] = B.data[j++];</span><br><span class="line">    C.length = k;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>8.已知在一维数组A[m +n]中依次存放两个线性表(a1, a2, a3,…,am)和(b1, b2, b3,…, bn)。编写一个函数，将数组中两个顺序表的位置互换，即将B放在A的前面。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//先对整体逆置，化为(bn,bn-1,...,b2,b1,am,am-1,...,a2,a1)，在对前n个元素和后m个元素分别使用逆置算法，即可实现顺序表的位置互换</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> DataType;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Reverse</span><span class="params">(DataType A[],<span class="keyword">int</span> left,<span class="keyword">int</span> right,<span class="keyword">int</span> arraySize)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(left&gt;=right||right&gt;=arraySize)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> mid = (left+right)/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=mid-left;i++)&#123;</span><br><span class="line">        DataType temp = A[left+i];</span><br><span class="line">        A[left+i] = A[right-i];</span><br><span class="line">        A[right-i] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Exchange</span><span class="params">(DataType A[],<span class="keyword">int</span> m,<span class="keyword">int</span> n,<span class="keyword">int</span> arraySize)</span></span>&#123;</span><br><span class="line">    Reverse(A,<span class="number">0</span>,m+n<span class="number">-1</span>,arraySize);</span><br><span class="line">    Reverse(a,<span class="number">0</span>,n<span class="number">-1</span>,arrySize);</span><br><span class="line">    Reverse(A,n,m+n<span class="number">-1</span>,arraySize);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>09．线性表(a1, a2, a3,.…, an)中的元素递增有序且按顺序存储于计算机内。要求设计一个算法，完成用最少时间在表中查找数值为x的元素，若找到，则将其与后继元素位置相交换，若找不到，则将其插入表中并使表中元素仍递增有序。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//折半查找法时间最快</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SearchExchangeInsert</span><span class="params">(Elemtype A[],Elemtype x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> low=<span class="number">0</span>,high=n<span class="number">-1</span>,mid;<span class="comment">//low和high指向顺序表的上届和下届</span></span><br><span class="line">    <span class="keyword">while</span>(low&lt;=high)&#123;</span><br><span class="line">        mid = (low+high)/<span class="number">2</span>;<span class="comment">//找到中间位置</span></span><br><span class="line">        <span class="keyword">if</span>(A[mid]==x) <span class="comment">//找到x，退出while循环</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">            <span class="keyword">if</span>(A[mid]&lt;x) low = mid+<span class="number">1</span>; <span class="comment">//到中点mid的右半部去查</span></span><br><span class="line">        <span class="keyword">else</span> high = mid<span class="number">-1</span>;<span class="comment">//到mid的左半部去查</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//下面两个if语句只会执行一个</span></span><br><span class="line">    <span class="keyword">if</span>(A[mid]==x &amp;&amp; mid!=n<span class="number">-1</span>)&#123;</span><br><span class="line">    <span class="comment">//若最后一个元素与x相等，则不存在与其后继交换的操作</span></span><br><span class="line">        t = A[mid];</span><br><span class="line">        A[mid] = A[mid+<span class="number">1</span>];</span><br><span class="line">        A[mid+<span class="number">1</span>] = t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(low&gt;high)&#123;</span><br><span class="line">    <span class="comment">//查找失败，插入元素x</span></span><br><span class="line">        <span class="keyword">for</span>(i=n<span class="number">-1</span>;i&gt;high;i++)<span class="comment">//后移元素</span></span><br><span class="line">            A[i+<span class="number">1</span>] = A[i];</span><br><span class="line">        A[i+<span class="number">1</span>] = x;<span class="comment">//插入x</span></span><br><span class="line">    &#125;<span class="comment">//结束插入</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>10.【2010统考真题】设将n (n&gt;1)个整数存放到一维数组R中。设计一个在时间和空间两方面都尽可能高效的算法。将R中保存的序列<strong>循环左移p（0&lt;p&lt;n）个位置</strong>，即将R中的数据由(X0,X1,…,Xn-1)变换为(Xp,Xp+1,…,Xn-1,X0,X1,…,Xp-1)。要求:</p><p>​    1）给出算法的基本设计思想。</p><p>可将这个问题视为把数组ab转换成数组ba（a代表数组的前p个元素，b代表数组中余下的n-p个元素），先将a逆置得a^-1^b，再将b逆置得a^-1^b^-1^，最后整个逆置得到(a^-1^b^-1^)^-1^=ba。设Reverse函数执行将数组元素逆置的操作，对abcdefgh向左循环移动3(p =3)个位置的过程如下:<br>    Reverse(0,p-1) 得到cbadefgh；<br>    Reverse (p,n-1)得到cbahgfed；<br>    Reverse (0,n-1)得到defghabc。</p><p>​    2）根据设计思想，采用C或C++或Java语言描述算法，关键之处给出注释。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Reverse</span><span class="params">(<span class="keyword">int</span> R[],<span class="keyword">int</span> from,<span class="keyword">int</span> to)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i,temp;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;(to-from+<span class="number">1</span>)/<span class="number">2</span>;i++)&#123;</span><br><span class="line">        temp = R[from+i];</span><br><span class="line">        R[from+i] = R[to+i];</span><br><span class="line">        R[to-i] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Converse</span><span class="params">(<span class="keyword">int</span> R[],<span class="keyword">int</span> n,<span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">    Reverse(R,<span class="number">0</span>,p<span class="number">-1</span>);</span><br><span class="line">    Reverse(R,p.n<span class="number">-1</span>);</span><br><span class="line">    Reverse(R,<span class="number">0</span>,n<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    3）说明你所设计算法的时间复杂度和空间复杂度。</p><p>上述算法中三个Reverse函数的时间复杂度分别为O(p/2)、O((n-p)/2)和 O(n/2)，故所设计的算法的时间复杂度为O(n)，空间复杂度为O(1)。</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;线性表的顺序表示&quot;&gt;&lt;a href=&quot;#线性表的顺序表示&quot; class=&quot;headerlink&quot; title=&quot;线性表的顺序表示&quot;&gt;&lt;/a&gt;线性表的顺序表示&lt;/h2&gt;&lt;p&gt;1.从顺序表删除具有最小值的元素（假设唯一）并由函数返回被删元素的值，空出的位置由最后元素填补，若顺序表为空，则显示出错信息并退出运行。&lt;/p&gt;</summary>
    
    
    
    <category term="笔记" scheme="https://fish-on-net.github.io/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="考研" scheme="https://fish-on-net.github.io/tags/%E8%80%83%E7%A0%94/"/>
    
    <category term="数据结构" scheme="https://fish-on-net.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    <category term="写死我了" scheme="https://fish-on-net.github.io/tags/%E5%86%99%E6%AD%BB%E6%88%91%E4%BA%86/"/>
    
  </entry>
  
  <entry>
    <title>关于电影</title>
    <link href="https://fish-on-net.github.io/june/2022-5-18-%E5%85%B3%E4%BA%8E%E7%94%B5%E5%BD%B1/"/>
    <id>https://fish-on-net.github.io/june/2022-5-18-%E5%85%B3%E4%BA%8E%E7%94%B5%E5%BD%B1/</id>
    <published>2022-05-17T16:00:00.000Z</published>
    <updated>2022-08-02T04:44:21.580Z</updated>
    
    <content type="html"><![CDATA[<p>原视频：<a href="https://www.bilibili.com/video/BV1Wf4y1D7wj">《关于电影 - About Cinematography》</a></p><p>片单：</p><ul><li><p>飞驰中的萨利·加德纳 Sallie Gardner at a Gallop (1878)</p></li><li><p>电力之战 The Current War (2017)</p></li><li><p>24帧 24 Frames (2017)</p></li><li><p>阴阳相成 Side by Side (2012)</p></li><li><p>迷幻 Trance (2013)</p></li><li><p>弗里达 Frida (2002)</p></li><li><p>女性瘾者：第一部 Nymphomaniac: Volume I (2013)</p></li><li><p>灯塔 The Lighthouse (2019)</p></li><li><p>Tito (2019)</p></li><li><p>我想结束这一切 I’m Thinking of Ending Things (2020)</p></li><li><p>极寒之城 Atomic Blonde (2017)</p></li><li><p>爆裂鼓手 Whiplash (2014)</p></li><li><p>降临 Arrival (2016)</p></li><li><p>法官老爹 The Judge (2014)</p></li><li><p>壁花少年 The Perks of Being a Wallflower (2012)</p></li><li><p>天才捕手 Genius (2016)</p></li><li><p>真心半解 The Half of It (2020)</p></li><li><p>搏击俱乐部 Fight Club (1999)</p></li><li><p>雨果 Hugo (2011)</p></li><li><p>杀死汝爱 Kill Your Darlings (2013)</p></li><li><p>无声的抵抗 Resistance (2020)</p></li><li><p>盗梦空间 Inception (2010)</p></li><li><p>源代码 Source Code (2011)</p></li><li><p>神枪手之死 The Assassination of Jesse James by the Coward Robert Ford (2007)</p></li><li><p>美少女特攻队 Sucker Punch (2011)</p></li><li><p>夏日之王 The Kings of Summer (2013)</p></li><li><p>土拨鼠之日 Groundhog Day (1993)</p></li><li><p>老男孩 Old Boy (2003)</p></li><li><p>超级八 Super 8 (2011)</p></li><li><p>银翼杀手2049 Blade Runner 2049 (2017)</p></li><li><p>从不，很少，有时，总是 Never Rarely Sometimes Always (2020)</p></li><li><p>党同伐异 Intolerance: Love’s Struggle Throughout the Ages (1916)</p></li><li><p>火车进站 L’arrivée d’un train à La Ciotat (1896)</p></li><li><p>圣山 The Holy Mountain (1973)</p></li><li><p>猴子 Monos (2019)</p></li><li><p>毕业生 The Graduate (1967)</p></li><li><p>第七封印 The Seventh Seal (1957)</p></li><li><p>比尔和泰德畅游鬼门关 Bill &amp; Ted’s Bogus Journey (1991)</p></li><li><p>花样年华 In the Mood for Love (2000)</p></li><li><p>元首偷走了粉兔子 When Hitler Stole Pink Rabbit (2019)</p></li><li><p>光荣之路 Paths of Glory (1957)</p></li><li><p>家庭罗曼史有限公司 Family Romance, LLC. (2019)</p></li><li><p>卡罗尔 Carol (2015)</p></li><li><p>一一 Yi yi (2000)</p></li><li><p>火车上的女孩 The Girl on the Train (2016)</p></li><li><p>公民凯恩 Citizen Kane (1941)</p></li><li><p>007：大战皇家赌场 Casino Royale (2006)</p></li><li><p>小丑 Joker (2019)</p></li><li><p>蝙蝠侠：黑暗骑士 The Dark Knight (2008)</p></li><li><p>和莎莫的500天 (500) Days of Summer (2009)</p></li><li><p>仲夏夜惊魂 Midsommar (2019)</p></li><li><p>夜空总有最大密度的蓝色 Tokyo Night Sky Is Always the Densest Shade of Blue (2017)</p></li><li><p>好莱坞往事 Once Upon a Time… in Hollywood (2019)</p></li><li><p>甜姐儿 Funny Face (1957)</p></li><li><p>黑客帝国 The Matrix (1999)</p></li><li><p>小小乔 Little Joe (2019)</p></li><li><p>告白 Confessions (2010)</p></li><li><p>安妮·霍尔 Annie Hall (1977)</p></li><li><p>海边的曼彻斯特 Manchester by the Sea (2016)</p></li><li><p>温蒂和露茜 Wendy and Lucy (2008)</p></li><li><p>剧场 Theater (2020)</p></li><li><p>象人 The Elephant Man (1980)</p></li><li><p>囚徒 Prisoners (2013)</p></li><li><p>乳牙 Babyteeth (2019)</p></li><li><p>活死人黎明 Dawn of the Dead (2004)</p></li><li><p>无耻混蛋 Inglourious Basterds (2009)</p></li><li><p>蓝白红三部曲之红 Three Colors: Red (1994)</p></li><li><p>社交网络 The Social Network (2010)</p></li><li><p>乡愁 Nostalghia (1983)</p></li><li><p>香槟 Champagne (1928)</p></li><li><p>坠入 The Fall (2006)</p></li><li><p>睡梦医生 Doctor Sleep (2019)</p></li><li><p>哈利·波特与魔法石 Harry Potter and the Sorcerer’s Stone (2001)</p></li></ul>]]></content>
    
    
    <summary type="html">马克个电影待看列表</summary>
    
    
    
    <category term="兴趣" scheme="https://fish-on-net.github.io/categories/%E5%85%B4%E8%B6%A3/"/>
    
    
    <category term="电影" scheme="https://fish-on-net.github.io/tags/%E7%94%B5%E5%BD%B1/"/>
    
    <category term="知识" scheme="https://fish-on-net.github.io/tags/%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>五月十一日·晚</title>
    <link href="https://fish-on-net.github.io/june/2022-05-11-%E4%BA%94%E6%9C%88%E5%8D%81%E4%B8%80%E6%97%A5%C2%B7%E6%99%9A/"/>
    <id>https://fish-on-net.github.io/june/2022-05-11-%E4%BA%94%E6%9C%88%E5%8D%81%E4%B8%80%E6%97%A5%C2%B7%E6%99%9A/</id>
    <published>2022-05-10T16:00:00.000Z</published>
    <updated>2022-05-11T12:55:07.478Z</updated>
    
    <content type="html"><![CDATA[<p>我觉得是不是全人类都有这个疑惑，就是：</p><p>每逢<strong>死线</strong>各种事情就都扎堆来了？</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;我觉得是不是全人类都有这个疑惑，就是：&lt;/p&gt;
&lt;p&gt;每逢&lt;strong&gt;死线&lt;/strong&gt;各种事情就都扎堆来了？&lt;/p&gt;
</summary>
      
    
    
    
    <category term="杂记" scheme="https://fish-on-net.github.io/categories/%E6%9D%82%E8%AE%B0/"/>
    
    
    <category term="我写不完了救命啊" scheme="https://fish-on-net.github.io/tags/%E6%88%91%E5%86%99%E4%B8%8D%E5%AE%8C%E4%BA%86%E6%95%91%E5%91%BD%E5%95%8A/"/>
    
  </entry>
  
  <entry>
    <title>长难句翻译</title>
    <link href="https://fish-on-net.github.io/june/2022-5-6-%E9%95%BF%E9%9A%BE%E5%8F%A5%E7%BF%BB%E8%AF%91/"/>
    <id>https://fish-on-net.github.io/june/2022-5-6-%E9%95%BF%E9%9A%BE%E5%8F%A5%E7%BF%BB%E8%AF%91/</id>
    <published>2022-05-05T16:00:00.000Z</published>
    <updated>2022-08-02T05:00:23.965Z</updated>
    
    <content type="html"><![CDATA[<h2 id="2-19"><a href="#2-19" class="headerlink" title="2~19"></a>2~19</h2><h3 id="DAY-02"><a href="#DAY-02" class="headerlink" title="DAY 02"></a>DAY 02</h3><p>The military is spending more money than ever to address mental health issues within the ranks, and their latest attempt is a smart phone application called the T2 MoodTracker application, which helps service members keep track of their mental health after deployments.</p><blockquote><p>军队正在花费比以往更多的钱来解决队伍中的心理健康问题，他们的最新尝试是一个名为T2 MoodTracker的智能手机应用程序，它帮助服役人员在部署后跟踪他们的心理健康。</p></blockquote><h3 id="DAY-07"><a href="#DAY-07" class="headerlink" title="DAY 07"></a>DAY 07</h3><p>A study by academics from the University of California and North-western University claimed that “the casual link between the consumption of restaurant foods and obesity is minimal at best.”</p><blockquote><p>加利福尼亚大学和西北大学的学者们的一项研究声称，”食用餐馆食品和肥胖之间的偶然联系充其量是微不足道的”。</p></blockquote><h3 id="DAY-11"><a href="#DAY-11" class="headerlink" title="DAY 11"></a>DAY 11</h3><p>Lisa Whittaker, a postgraduate student at the University of Stirling, who studied teens aged 16-18 in Scotland, said the slang had been created to keep their activities private,and cited the example of one young girl who was sacked after bosses found pictures of her drinking on the website.</p><blockquote><p>研究苏格兰16-18岁青少年的斯特林大学研究生Lisa Whittaker说，创造这种俚语是为了保持他们活动的私密性，并列举了一个年轻女孩的例子，她在老板发现她网上喝酒的照片后被解雇了。</p></blockquote><h2 id="20-29"><a href="#20-29" class="headerlink" title="20~29"></a>20~29</h2><h3 id="DAY-20"><a href="#DAY-20" class="headerlink" title="DAY 20"></a>DAY 20</h3><p>Even adults can benefit from the practice when studying new graphically different languages– such as Chinese– or symbols in sciences such as chemistry.</p><blockquote><p>即使是成年人，在学习新的截然不同的图形化语言（如汉语）或科学符号（如化学符号）时，也能从中受益。</p></blockquote><h3 id="DAY-21"><a href="#DAY-21" class="headerlink" title="DAY 21"></a>DAY 21</h3><p>For anyone whose kids balk at or have trouble with traditional handwriting instruction, the arrival of new educational games for the iPhone, iPad and other touch screen devices may come as a welcome teaching aid.</p><blockquote><p>对于那些不愿接受传统手写教学或有困难的孩子来说，适用于 iPhone、iPad 和其他触摸屏设备的新教育游戏的到来可能会成为一种受欢迎的教学辅助工具。</p></blockquote><h3 id="DAY-22"><a href="#DAY-22" class="headerlink" title="DAY 22"></a>DAY 22</h3><p>If you want to boost your child’s results at school, you could do a lot worse than ensuring that they do plenty of exercise.</p><blockquote><p>如果你想让你的孩子在学校表现更加优异一些，你最好确保他们多锻炼。</p></blockquote><h3 id="DAY-23"><a href="#DAY-23" class="headerlink" title="DAY 23"></a>DAY 23</h3><p>But a team in America has used scans to show that an important part of the brain actually grows in children who are fit skill development.</p><blockquote><p>但是美国的一个研究小组通过扫描显示，健康的儿童大脑的一个重要部分实际是发育的。</p></blockquote><h3 id="DAY-24"><a href="#DAY-24" class="headerlink" title="DAY 24"></a>DAY 24</h3><p>They believe that encouraging children to take exercise from a very young age could help them do better at school later.</p><blockquote><p>他们认为，鼓励孩子从小就锻炼可以帮助他们以后在学校表现得更好。</p></blockquote><h3 id="DAY-25"><a href="#DAY-25" class="headerlink" title="DAY 25"></a>DAY 25</h3><p>Researchers from the University of Illinois, in the U.S., studied the brains of 49 children aged nin and ten using a magnetic resonance imaging scan(磁共振成像扫描), a technique which provides very detailed pictures of organs and tissues in the body.</p><blockquote><p>美国伊利诺斯大学的研究人员使用磁共振成像扫描技术对49名9岁和10岁的儿童的大脑进行了研究，该技术可以提供非常详细的人体器官和组织的图片。</p></blockquote><h3 id="DAY-26"><a href="#DAY-26" class="headerlink" title="DAY 26"></a>DAY 26</h3><p>The professor who led the study said the findings had important implications for encouraging individuals to take part in sport from a young age.</p><blockquote><p>领导这项研究的教授说，这些发现对于鼓励人们从小就参与体育运动有着重要的意义。</p></blockquote><h3 id="DAY-27"><a href="#DAY-27" class="headerlink" title="DAY 27"></a>DAY 27</h3><p>The study assessed 1000 teenagers in China with an average age of 15 years for depression and anxiety, reports the journal.</p><blockquote><p>该杂志报道，这项研究评估了1000名平均年龄为15岁的中国青少年的抑郁和焦虑情绪。</p></blockquote><h3 id="DAY-28"><a href="#DAY-28" class="headerlink" title="DAY 28"></a>DAY 28</h3><p>It included questions such as: “How often do you feel depressed, moody or nervous when you are offline, which goes away once you are back online?”</p><blockquote><p>它包括这样的问题：“当你离线时，你多久一次感到抑郁、情绪化或紧张？而当你回到线上时，这些症状就会消失。”</p></blockquote><h3 id="DAY-29"><a href="#DAY-29" class="headerlink" title="DAY 29"></a>DAY 29</h3><p>The result suggests that young people who are initially free of mental health promblems but use the internet pathologically(病理上) could develop depression as a consequence.</p><blockquote><p>这一结果表明，那些最初没有心理健康问题，但病态的使用互联网的年轻人可能会因此患上抑郁症。</p></blockquote><h2 id="外刊阅读"><a href="#外刊阅读" class="headerlink" title="外刊阅读"></a>外刊阅读</h2><h4 id="DAY-23-1"><a href="#DAY-23-1" class="headerlink" title="DAY 23"></a>DAY 23</h4><p>You might think fear and envy about housing is part of the human condition. In fact, the property pathology has its roots in a shift in public policy in the 1950s toward promoting home ownership. Since then governments have used subsidies, tax breaks and sales of public housing to encourage owner-occupation over renting.</p><blockquote><p> 你可能认为对住房的恐惧和羡慕是人类状况的一部分。事实上，房产病症的根源在于20世纪50年代公共政策向促进住房所有权的转变。从那时起，政府利用补贴、减税和出售公共住房来鼓励自住而不是租房。</p></blockquote>]]></content>
    
    
    <summary type="html">长难句翻译每日一句（显然我并没有做到）以及一些外刊阅读笔记</summary>
    
    
    
    <category term="笔记" scheme="https://fish-on-net.github.io/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="英语" scheme="https://fish-on-net.github.io/tags/%E8%8B%B1%E8%AF%AD/"/>
    
    <category term="考研" scheme="https://fish-on-net.github.io/tags/%E8%80%83%E7%A0%94/"/>
    
  </entry>
  
  <entry>
    <title>OS课堂笔记</title>
    <link href="https://fish-on-net.github.io/june/2022-5-4-OS%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0/"/>
    <id>https://fish-on-net.github.io/june/2022-5-4-OS%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0/</id>
    <published>2022-05-03T16:00:00.000Z</published>
    <updated>2022-05-15T01:52:07.347Z</updated>
    
    <content type="html"><![CDATA[<h2 id="3-2"><a href="#3-2" class="headerlink" title="3/2"></a>3/2</h2><p><code>rm fs.img</code>：删除fs.img文件</p><p><code>$ make fs.img</code></p><p>若是最新，则回报：<code>make: “fs.img”已是最新。</code></p><p>非最新，则回报：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">./mkfs fs.img README _cat _echo _forktest _grep _init _kill _ln _ls _mkdir _rm _sh _stressfs _usertests _wc _zombie   <span class="comment">//./mkfs：执行mkfs文件；fs.img：输出的文件名；fs.img后面是所有要打包的文件的文件名，注意有些文件名前有下划线，有些没有（如README）。</span></span><br><span class="line">nmeta <span class="number">59</span> (boot, super, <span class="built_in">log</span> blocks <span class="number">30</span> inode blocks <span class="number">26</span>, bitmap blocks <span class="number">1</span>) blocks <span class="number">941</span> total <span class="number">1000</span>  <span class="comment">//boot block占1，super block占1，log（日志块）占30，inode blocks（i结点块）占26，bitmap block占1，1+1+30+26+1=59，59+941=1000 </span></span><br><span class="line">balloc: first <span class="number">666</span> blocks have been allocated <span class="comment">//前666个blocks（块）还没有分配。</span></span><br><span class="line">balloc: write bitmap block at sector <span class="number">58</span>  <span class="comment">//bitmap block(位映射块)放在扇区58（从0开始，0:boot block，1:super block，2~31:log，32~57:inode block，58:bitmap block）</span></span><br></pre></td></tr></table></figure><p><strong>在fs.img中打包一个新文件进去</strong>：<br>修改Makefile第185-186行，将新文件名添加在末尾（或$(UPROGS)前面）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">185</span> fs.img: mkfs README $(UPROGS) new_file.txt</span><br><span class="line"><span class="number">186</span>         ./mkfs fs.img README new_file.txt $(UPROGS) </span><br></pre></td></tr></table></figure><p>然后执行<br><code>make clean</code><br><code>make qemu-nox</code>：生成可执行的系统（只<code>make</code>的话是生成xv6）<br>可以看见<code>./mkfs fs.img README _cat _echo _forktest _grep _init _kill _ln _ls _mkdir _rm _sh _stressfs _usertests _wc _zombie  new_file.txt </code>，其末尾增加了new_file.txt</p><p>在虚拟机中<code>ls</code>，也可以看见新增了new_file.txt，输入<code>cat new_file.txt</code>可以查看其中内容。</p><h3 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h3><p>一个文件最大有140块（12个直接块，128个间接块），最大为71680字节。</p><p><code>fs.h</code>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NDIRECT 12  <span class="comment">//一个文件有12个直接块</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NINDIRECT (BSIZE / sizeof(uint))  <span class="comment">//间接块数量=512/4(每个条目占4字节)=128块</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXFILE (NDIRECT + NINDIRECT)     <span class="comment">//一个文件最多有多少块</span></span></span><br><span class="line"><span class="comment">// 一个文件最大大小=最多块数*块的大小=(12+128)*512=71680字节(Byte)</span></span><br></pre></td></tr></table></figure><blockquote><p>1Byte = 8bit</p></blockquote><p>一个文件系统必有i结点，存储索引信息等。</p><h4 id="术语："><a href="#术语：" class="headerlink" title="术语："></a>术语：</h4><ol><li>data block <strong>数据块</strong><br>用来放置文件内容。</li><li>super block <strong>超级块</strong><br>主要记录文件系统的整体信息。</li><li>inode <strong>索引节点</strong>（i节点）<br>主要记录文件的属性、权限以及该文件实际数据的位置（所在block号）。<ul><li>inode的大小固定，一个文件占用一个inode。</li><li>文件系统能创建的文件数量与inode的数量相关。</li></ul></li><li>bitmap <strong>映射表/对照表</strong><ol><li>block bitmap：区块对照表<br>记录使用与未使用的block号，并在文件添加修改时对应地修改block的使用状况。</li><li>inode bitmap：inode对照表<br>记录使用与未使用的inode号，并在文件添加修改时对应地修改inode的使用状况</li></ol></li></ol><h4 id="磁盘组成："><a href="#磁盘组成：" class="headerlink" title="磁盘组成："></a>磁盘组成：</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Disk layout:</span><br><span class="line">[ boot block | sb block | <span class="built_in">log</span> | inode blocks | <span class="built_in">free</span> bit <span class="built_in">map</span> | data blocks ]</span><br></pre></td></tr></table></figure><h4 id="查看fs-img"><a href="#查看fs-img" class="headerlink" title="查看fs.img"></a>查看fs.img</h4><p>执行<br><code>vim fs.img</code> 打开fs.img<br><code>:%!xxd</code> 用二进制查看</p><ul><li>boot块：第1~32行，即<code>00000000</code>~<code>000001f0</code></li><li>super块：第32-行，即<code>00000200</code>~<code>000002f0</code></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">33 00000200: e803 0000 ad03 0000 c800 0000 1e00 0000  ................</span><br></pre></td></tr></table></figure><p><code>e802 0000</code>：(3E8)<del>16</del> = (1000)<del>10</del> ，表示文件系统的大小（总块数）；<br><code>ad03 0000</code>：(3AD)<del>16</del> = (941)<del>10</del> ，表示data block的数量；<br><code>c800 0000</code>：(C8)<del>16</del> = (200)<del>10</del> ，表示inode的数量；<br><code>1e00 0000</code>：(1E)<del>16</del> = (30)<del>10</del> ，表示log block的数量。</p><h3 id="mkfs-c"><a href="#mkfs-c" class="headerlink" title="mkfs.c"></a>mkfs.c</h3><h4 id="变量variables"><a href="#变量variables" class="headerlink" title="变量variables"></a>变量variables</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">nbitmap</span><br><span class="line">ninodeblocks</span><br><span class="line">nlog</span><br><span class="line">nmeta <span class="comment">//元块，boot block，sb block，log，inode blocks和free bitmap的总块数</span></span><br><span class="line">nblocks <span class="comment">//data blocks的块数 nmeta+nblocks=整个盘片所有的块数</span></span><br><span class="line">fsfd</span><br><span class="line">sb <span class="comment">//超级块</span></span><br><span class="line">zeroes</span><br><span class="line">freeinode </span><br><span class="line">freeblock</span><br></pre></td></tr></table></figure><h4 id="函数functions"><a href="#函数functions" class="headerlink" title="函数functions"></a>函数functions</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">xshort(ushort x)</span><br><span class="line">xint(uint x)</span><br><span class="line">main(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span><br><span class="line">balloc(<span class="keyword">int</span> used)<span class="comment">//分配一个块</span></span><br><span class="line">wsect(uint sec, <span class="keyword">void</span> *buf)<span class="comment">//写一个块</span></span><br><span class="line">rsect(uint sec, <span class="keyword">void</span> *buf)<span class="comment">//读一个块</span></span><br><span class="line">winode(uint inum, struct dinode *ip) <span class="comment">//写一个inode</span></span><br><span class="line">rinode(uint inum, struct dinode *ip) <span class="comment">//读一个inode</span></span><br><span class="line">ialloc(ushort type)<span class="comment">//分配i节点</span></span><br><span class="line">iappend(uint inum, <span class="keyword">void</span> *xp, <span class="keyword">int</span> n)<span class="comment">//追加i节点</span></span><br></pre></td></tr></table></figure><p><code>mkfs.c &gt; main()</code>中：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">bzero(&amp;de, <span class="keyword">sizeof</span>(de)); </span><br><span class="line">de.inum = xshort(rootino);  </span><br><span class="line"><span class="built_in">strcpy</span>(de.name, <span class="string">&quot;.&quot;</span>); </span><br><span class="line">iappend(rootino, &amp;de, <span class="keyword">sizeof</span>(de));  </span><br><span class="line"></span><br><span class="line">bzero(&amp;de, <span class="keyword">sizeof</span>(de));</span><br><span class="line">de.inum = xshort(rootino);</span><br><span class="line"><span class="built_in">strcpy</span>(de.name, <span class="string">&quot;..&quot;</span>);  </span><br><span class="line">iappend(rootino, &amp;de, <span class="keyword">sizeof</span>(de));</span><br></pre></td></tr></table></figure><p>往根目录下追加了两个目录项“.”和“..”，他们都指向根目录。<code>cd .</code>和<code>cd ..</code>都只会跳到根目录。<br>即<code>ls</code>命令后出现的前两行，大小都是512（占一个块）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">.              1 1 512</span><br><span class="line">..             1 1 512</span><br><span class="line">README         2 2 2286</span><br><span class="line">cat            2 3 16256</span><br><span class="line">echo           2 4 15112</span><br><span class="line">forktest       2 5 9420</span><br><span class="line">grep           2 6 18476</span><br><span class="line">init           2 7 15696</span><br><span class="line">kill           2 8 15144</span><br><span class="line">ln             2 9 14996</span><br><span class="line">ls             2 10 17624</span><br><span class="line">mkdir          2 11 15240</span><br><span class="line">rm             2 12 15216</span><br><span class="line">sh             2 13 27860</span><br><span class="line">stressfs       2 14 16132</span><br><span class="line">usertests      2 15 67236</span><br><span class="line">wc             2 16 16996</span><br><span class="line">zombie         2 17 14808</span><br><span class="line">new_file.txt   2 18 23</span><br><span class="line">console        3 19 0</span><br></pre></td></tr></table></figure><h3 id="Makefile-gt-xv6-pdf"><a href="#Makefile-gt-xv6-pdf" class="headerlink" title="Makefile &gt; xv6.pdf"></a>Makefile &gt; xv6.pdf</h3><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">xv6.pdf:</span> <span class="string">$(PRINT)</span></span><br><span class="line"><span class="string">./runoff</span></span><br><span class="line"><span class="string">ls</span> <span class="string">-l</span> <span class="string">xv6.pdf</span></span><br><span class="line"></span><br><span class="line"><span class="attr">print:</span> <span class="string">xv6.pdf</span></span><br></pre></td></tr></table></figure><p>执行<code>make xv6.pdf</code>，如果没错会生成一个<code>xv6.pdf</code></p><h2 id="4-9"><a href="#4-9" class="headerlink" title="4/9"></a>4/9</h2><h3 id="可执行文件"><a href="#可执行文件" class="headerlink" title="可执行文件"></a>可执行文件</h3><p><code>ls _*</code>可以看到所有首位是下划线的文件，这些文件是<strong>可执行文件</strong>。在系统中不显示下划线。</p><p><code>file</code>查看它们的属性可知是32位的程序，Intel 80386，静态链接的（statically linked）。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ file _cat</span><br><span class="line">_cat: ELF <span class="number">32</span>-bit LSB executable, Intel <span class="number">80386</span>, version <span class="number">1</span> (SYSV), statically linked, with debug_info, <span class="keyword">not</span> stripped</span><br></pre></td></tr></table></figure><p><code>_xxx</code>通常编译自<code>xxx.c</code>。</p><p><code>cat.c</code>的头文件有：</p><ul><li>types.h：给类型取别名。</li><li>stat.h：用编号定义目录、文件、设备和一个状态结构体stat。</li><li>user.h：系统调用和类似c语言标准库中的函数ulib.c</li></ul><p>启动一个进程时会隐形地打开3个文件：</p><ul><li>0号：标准输入文件</li><li>1号：标准输出文件，</li><li>2号：标准错误输出文件</li></ul><p>执行<code>cat</code>时若不带参数则以键盘的输入为参数，输出输入的内容（按<code>CTRL+D</code>退出）；带参数则输入参数中的内容。</p><h4 id="下划线的规定"><a href="#下划线的规定" class="headerlink" title="下划线的规定"></a>下划线的规定</h4><p><code>Makefile</code>：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 所有带下划线的可执行文件依赖于不带下划线的.o文件与用户库文件</span></span><br><span class="line"><span class="string">_%:</span> <span class="string">%.o</span> <span class="string">$(ULIB)</span></span><br><span class="line"><span class="string">$(LD)</span> <span class="string">$(LDFLAGS)</span> <span class="string">-N</span> <span class="string">-e</span> <span class="string">main</span> <span class="string">-Ttext</span> <span class="number">0</span> <span class="string">-o</span> <span class="string">$@</span> <span class="string">$^</span></span><br><span class="line"><span class="string">$(OBJDUMP)</span> <span class="string">-S</span> <span class="string">$@</span> <span class="string">&gt;</span> <span class="string">$*.asm</span></span><br><span class="line"><span class="string">$(OBJDUMP)</span> <span class="string">-t</span> <span class="string">$@</span> <span class="string">|</span> <span class="string">sed</span> <span class="string">&#x27;1,/SYMBOL TABLE/d; s/ .* / /; /^$$/d&#x27;</span> <span class="string">&gt;</span> <span class="string">$*.sym</span></span><br></pre></td></tr></table></figure><h4 id="系统自带的可执行文件"><a href="#系统自带的可执行文件" class="headerlink" title="系统自带的可执行文件"></a>系统自带的可执行文件</h4><ul><li><p>cat</p></li><li><p>echo：将参数标准输出（STDOUT），即在显示器上输出。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ echo hello</span><br><span class="line">hello</span><br><span class="line">$ echo 重复这句话</span><br><span class="line">重复这句话</span><br></pre></td></tr></table></figure></li><li><p>ln</p></li><li><p>ls</p></li><li><p>mkdir：创建目录</p></li><li><p>rm：删除文件</p></li><li><p>forktest：创建子进程</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ forktest</span><br><span class="line">fork test</span><br><span class="line">fork test OK</span><br></pre></td></tr></table></figure></li></ul><h3 id="打包程序至系统"><a href="#打包程序至系统" class="headerlink" title="打包程序至系统"></a>打包程序至系统</h3><ol><li><p>写一个可执行的.c文件（以<code>hello.c</code>为例），注意头文件和系统自带函数。</p></li><li><p>在Makefile的UPROGS中添加文件名，fs.img打包时就会打包进去。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">UPROGS&#x3D;\</span><br><span class="line">     _cat\</span><br><span class="line">     _echo\</span><br><span class="line">     _hello\   ←添加的文件</span><br></pre></td></tr></table></figure></li><li><p><code>make clean</code>，<code>make</code></p></li><li><p><code>make qemu-nox</code>可以看到可执行文件<code>hello</code>出现在了根目录下。</p></li><li><p>执行<code>hello</code>可以正常运行。</p></li></ol><h3 id="作业：写一个copy"><a href="#作业：写一个copy" class="headerlink" title="作业：写一个copy"></a>作业：写一个copy</h3><p>→见cp.c</p><h3 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h3><p>执行<code>make qemu-nox-gdb</code></p><p>在无图形化界面启动gdb。</p><h2 id="4-16"><a href="#4-16" class="headerlink" title="4/16"></a>4/16</h2><h3 id="作业：改写printf"><a href="#作业：改写printf" class="headerlink" title="作业：改写printf"></a>作业：改写printf</h3><ol><li><code>vim printf.c</code><br>修改putc()函数，修改printf()函数，并且在<code>user.h</code>和<code>ulib.c</code>中添加。</li><li><code>vim newtest.c</code><br>使printf()输出浮点数</li></ol><h3 id="syscalls"><a href="#syscalls" class="headerlink" title="syscalls"></a>syscalls</h3><p><code>git checkout -b syscalls</code>：新建并切换到syscalls分支。</p><p><code>grep fork *.c *.S &gt; syscall_fork.txt</code>：将和系统调用<code>fork</code>有关的信息都保存至syscall_fork.txt中，删除其中不重要的信息，得4个重要的文件：</p><blockquote><p><strong>proc.c</strong>:extern void forkret(void);<br><strong>syscall.c</strong>:extern int sys_fork(void);<br><strong>sysproc.c</strong>:sys_fork(void)<br><strong>usys.S</strong>:SYSCALL(fork)</p></blockquote><p>同理，查看另一个系统调用mknod，<code>grep mknod *.c *.S</code>：</p><blockquote><p>init.c:    mknod(“console”, 1, 1);<br>syscall.c:extern int sys_mknod(void);<br>syscall.c:[SYS_mknod]   sys_mknod,<br>sysfile.c:sys_mknod(void)<br>usys.S:SYSCALL(mknod)</p></blockquote><p><code>grep sys_fork *.c *.S</code>：</p><blockquote><p>syscall.c:extern int sys_fork(void);<br>syscall.c:[SYS_fork]    sys_fork,<br>sysproc.c:sys_fork(void)</p></blockquote><h4 id="traps-h"><a href="#traps-h" class="headerlink" title="traps.h"></a>traps.h</h4><p>存储着所有的中断号，若要添加中断可以在其中添加。</p><h4 id="syscall-c"><a href="#syscall-c" class="headerlink" title="syscall.c"></a>syscall.c</h4><p>存储着一个系统调用向量表：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="title">int</span> <span class="params">(*syscalls[])</span><span class="params">(<span class="keyword">void</span>)</span> </span>= &#123;</span><br><span class="line">[SYS_fork]    sys_fork,</span><br><span class="line">···（中间略）</span><br><span class="line">[SYS_close]   sys_close,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>还有一些从栈上获取信息的辅助函数。</p><h4 id="proc-c"><a href="#proc-c" class="headerlink" title="proc.c"></a>proc.c</h4><p>函数：</p><ul><li>int fork(void)</li><li>void exit(void)</li><li>int wait(void)</li><li>void shceduler(void) ：调度器</li></ul><h4 id="sysproc-c"><a href="#sysproc-c" class="headerlink" title="sysproc.c"></a>sysproc.c</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span></span><br><span class="line">sys_fork(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> fork();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过代码处理，实现从fork到sys_fork。</p><h4 id="user-h-gt-system-calls"><a href="#user-h-gt-system-calls" class="headerlink" title="user.h &gt; system calls"></a>user.h &gt; system calls</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fork</span><span class="params">(<span class="keyword">void</span>)</span></span>;                           <span class="comment">//创建一个新进程</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">exit</span><span class="params">(<span class="keyword">void</span>)</span> __<span class="title">attribute__</span><span class="params">((noreturn))</span></span>; <span class="comment">//结束进程</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">wait</span><span class="params">(<span class="keyword">void</span>)</span></span>;                           <span class="comment">//等待子进程结束</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pipe</span><span class="params">(<span class="keyword">int</span> *)</span></span>;                          <span class="comment">//创建一个管道</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">write</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">const</span> <span class="keyword">void</span> *, <span class="keyword">int</span>)</span></span>;        <span class="comment">//写文件</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">void</span> *, <span class="keyword">int</span>)</span></span>;               <span class="comment">//读文件</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">close</span><span class="params">(<span class="keyword">int</span>)</span></span>;                           <span class="comment">//关闭文件</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">kill</span><span class="params">(<span class="keyword">int</span>)</span></span>;                            <span class="comment">//杀死一个进程</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">exec</span><span class="params">(<span class="keyword">char</span> *, <span class="keyword">char</span> **)</span></span>;                <span class="comment">//在当前进程地址空间中加载一个新可执行程序</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">open</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *, <span class="keyword">int</span>)</span></span>;              <span class="comment">//打开一个文件</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mknod</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *, <span class="keyword">short</span>, <span class="keyword">short</span>)</span></span>;    <span class="comment">//创建一个设备文件</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">unlink</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *)</span></span>;                 <span class="comment">//断开文件名与对应i节点的链接，当i节点的链接数为0时，删除相应文件</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fstat</span><span class="params">(<span class="keyword">int</span> fd, struct stat *)</span></span>;         <span class="comment">//获取文件的相关信息</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">link</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *, <span class="keyword">const</span> <span class="keyword">char</span> *)</span></span>;     <span class="comment">//硬连接，不同文件名对应同一个i节点</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mkdir</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *)</span></span>;                  <span class="comment">//创建目录</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">chdir</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *)</span></span>;                  <span class="comment">//改变进程的当前目录</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dup</span><span class="params">(<span class="keyword">int</span>)</span></span>;                             <span class="comment">//复制文件描述符，用于IO重定向</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getpid</span><span class="params">(<span class="keyword">void</span>)</span></span>;                         <span class="comment">//获取当前进程的进程标志符</span></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">sbrk</span><span class="params">(<span class="keyword">int</span>)</span></span>;                          <span class="comment">//扩充进程的地址空间大小，用于实现malloc</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sleep</span><span class="params">(<span class="keyword">int</span>)</span></span>;                           <span class="comment">//进程睡眠</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">uptime</span><span class="params">(<span class="keyword">void</span>)</span></span>;                         <span class="comment">//获取开机以来的系统运行时间</span></span><br></pre></td></tr></table></figure><h4 id="系统调用的过程"><a href="#系统调用的过程" class="headerlink" title="系统调用的过程"></a>系统调用的过程</h4><p>以fork为例</p><ol><li>获取进程号码<strong>NUM</strong></li><li><strong>usys.S (int 64 [eax = NUM])</strong><br>陷入指令</li><li><strong>syscall.c [table, 完成调用]</strong></li><li><strong>sys_fork</strong></li><li><strong>fork()</strong></li></ol><h4 id="sys-read"><a href="#sys-read" class="headerlink" title="sys_read()"></a>sys_read()</h4><p>sysfile.c</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span></span><br><span class="line">sys_read(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">f</span>;</span></span><br><span class="line">  <span class="keyword">int</span> n;</span><br><span class="line">  <span class="keyword">char</span> *p;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 获取函数的参数(fd,int,ptr)</span></span><br><span class="line">  <span class="keyword">if</span>(argfd(<span class="number">0</span>, <span class="number">0</span>, &amp;f) &lt; <span class="number">0</span> || argint(<span class="number">2</span>, &amp;n) &lt; <span class="number">0</span> || argptr(<span class="number">1</span>, &amp;p, n) &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">return</span> fileread(f, p, n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">虽然是我自己写的但我自己也看不懂，所以如果你们看不懂不要惊慌，因为我也看不懂。</summary>
    
    
    
    <category term="笔记" scheme="https://fish-on-net.github.io/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="操作系统实验" scheme="https://fish-on-net.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AE%9E%E9%AA%8C/"/>
    
  </entry>
  
  <entry>
    <title>嵌入式应用笔记</title>
    <link href="https://fish-on-net.github.io/june/2022-4-1-%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%AC%94%E8%AE%B0/"/>
    <id>https://fish-on-net.github.io/june/2022-4-1-%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%AC%94%E8%AE%B0/</id>
    <published>2022-03-31T16:00:00.000Z</published>
    <updated>2022-05-06T14:51:26.202Z</updated>
    
    <content type="html"><![CDATA[<h2 id="3-4"><a href="#3-4" class="headerlink" title="3/4"></a>3/4</h2><p><strong>1.用直白的话,概述下列的函数的实现过程,并重点解释temp = (c&gt;&gt;j) &amp; 0x01;gpio_set (led_d[j], temp);的作用.</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LEDshow1</span><span class="params">(uint_8 i, uint_8 c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  uint_8 temp;</span><br><span class="line">  uint_8 j;</span><br><span class="line">  <span class="comment">//位选全部置0=不选中</span></span><br><span class="line">  <span class="keyword">for</span> (j=<span class="number">0</span>;j&lt;=<span class="number">3</span>;j++)</span><br><span class="line">  gpio_set (led_cs[j], <span class="number">0</span>);</span><br><span class="line">  <span class="comment">//数据上线</span></span><br><span class="line">  <span class="keyword">for</span> (j=<span class="number">0</span>;j&lt;=<span class="number">7</span>;j++)</span><br><span class="line">  &#123;</span><br><span class="line">  temp = (c&gt;&gt;j) &amp; <span class="number">0x01</span>;  <span class="comment">//</span></span><br><span class="line">  gpio_set (led_d[j], temp);</span><br><span class="line">   &#125;</span><br><span class="line">  <span class="comment">//选择的位选置1</span></span><br><span class="line">  gpio_set (led_cs[i], <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>答：为了方便叙说，位号指4位LED的某位，引脚号指数据线的8位的某个引脚。<br>直白叙述：<br>（1）先通过第一个循环，将每个位置为0，即LED的每一位都不选中，<br>（2）接着通过第二个循环，是将数据线的每个引脚设置相应的数据，具体是通过temp = (c&gt;&gt;j) &amp; 0x01的c&gt;&gt;j先将j位的移至最后位，再与0x01相与，j位的值给temp(准确地是temp的最后一位，其他位无意义)，接着通过gpio_set (led_d[j], temp)，由temp给led_d[j]，即实现将c的j位值给了led_d[j]对应的引脚，如此循环8次，数据线8位得到相应数值。<br>（3）最后通过gpio_set (led_cs[i], 1)将LED位号i的相应数字显示。</p><br><p><strong>2.问一次调用LEDshow(uint_8 data[4]),显示LED的4位的几位？</strong></p><p>答：一次调用LEDshow，显示LED的某1位。</p><h2 id="3-11"><a href="#3-11" class="headerlink" title="3/11"></a>3/11</h2><p><strong>1、Flash的写、擦除的操作是怎样？</strong><br>答：1.（1）擦除的操作：将存储单元的二进制内容由0变1；（2）写的操作：将存储单元的二进制内容由1变0</p><br><p><strong>2、写出下列所指地址，并说出此地址是什么地方，作用是干什么的？</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 设置目标地址</span></span><br><span class="line">FTFA_FCCOB1 = <span class="number">0x00</span>;</span><br><span class="line">FTFA_FCCOB2 = <span class="number">0x04</span>;</span><br><span class="line">FTFA_FCCOB3 = <span class="number">0x0C</span>;</span><br></pre></td></tr></table></figure><p>答：地址：0x00040c，该地址为Flash加密寄存器，作用是将加密数据或不加密数据写入该地址，完成加密或不加密操作。</p><br><p><strong>3、Flash读的流程图</strong><br>答：逻辑地址读和物理地址读的两个流程图</p><p><img src="E:\学习\大三下\嵌入式应用\QQ图片20220318102504.jpg" alt="读的流程图"></p><br><p><strong>4.Flash写的流程图</strong></p><p><img src="E:\学习\大三下\嵌入式应用\QQ图片20220318102512.jpg" alt="写的流程图"></p><br><p><strong>5.擦除的流程图</strong></p><p><img src="E:\学习\大三下\嵌入式应用\QQ图片20220318102516.jpg" alt="擦除的流程图"></p><br><p><strong>6.区域保护的流程图</strong></p><p><img src="E:\学习\大三下\嵌入式应用\QQ图片20220318102521.jpg" alt="区域保护"></p><br><h2 id="3-18"><a href="#3-18" class="headerlink" title="3/18"></a>3/18</h2><p><strong>1、什么是ADC模块，其作用又是什么？</strong></p><p>ADC模块：模/数转换模块，又可以称作AD转换模块；功能是将电压信号转换为相应的数字信号。</p><br><p><strong>2、与AD转换编程直接相关的基本问题有哪些？</strong></p><p>转换精度、转换速度、单端输入与差分输入、AD参考电压、滤波问题、物理量回归。</p><br><p><strong>3、理论上，KL25中有多少个模拟输入通道？芯片内部包含一个温度传感器，其通道号是多少?</strong></p><p>26个。</p><p>温度传感器通道号：26。</p><br><p><strong>4、数据结果寄存器在不同的模式下数据表达情况，其中有多位符号位，如何理解？举例说明。</strong></p><p>数据有效位只有4位，前面可以视作只有1位符号，也可视作有多位符号。</p><br><p><strong>5、DA转换器一般由哪些部分组成的？</strong></p><p>DA转换器一般由数码缓冲寄存器、模拟电子开关、参考电压、解码网络和求和电路等组成。</p><br><p><strong>6、在本书选用的KL25封装中，DA模块多少个对外引脚？</strong></p><p>1个对外引脚，PTE30。</p><br><p><strong>7、画出adc_read的编程流程图。</strong></p><br><p><strong>8、计算</strong></p><p><strong>(1)  B=0xFC;A=0b00000100 | B;那么 A=?</strong></p><p><strong>(2)  B=0xAD;A=0b00000100 &amp; B;那么 A=?</strong></p><p><strong>(3)  A=0x33;A |= 0x01;A=?</strong></p><p><strong>(4)  A=0xAD;A &amp;= ~0x01;A=?</strong> </p><p>（1）A=0xFC</p><p>（2）A=0x04</p><p>（3）A=0x33</p><p>（4）A=0xAC</p><br><h2 id="3-25"><a href="#3-25" class="headerlink" title="3/25"></a>3/25</h2><p><strong>1、SPI是异步还是同步的串行通信方式?</strong></p><p>SPI同步串行通讯。</p><br><p><strong>2、SPI可以作半双工还是全双工通信？</strong></p><p>全双工。</p><br><p><strong>3、MISO和MOSI分别是什么意思？</strong></p><p>MISO：主机输入/从机输出数据线。</p><p>MOSI：主机输出/从机输入数据线。</p><br><p><strong>4、SPI的SCK是谁提供的？并控制着谁的通信？</strong></p><p>SCK：串行时钟线。</p><p>串行时钟信号由主机的内部总线时钟分频获得，主机的SCK引脚输出给从机的SCK引脚，控制整个数据的传输速度。</p><br><p><strong>5、SPI有哪些常用波特率的值？</strong></p><p>可取12000、6000、4000、3000、1500、1000bps。</p><br><p><strong>6、SPI通信时有两个重要的参数CPOL和CPHA，由此获得几种通信时序？</strong></p><p>时钟极性由CPOL控制，时钟相位由CPHA来控制，二者组合起来共有四种可能的取值情况，具体如下：</p><p>（1）空闲电平低电平，上升沿取数（CPOL=0，CPHA=0）</p><p>（2）空闲电平低电平，下降沿取数（CPOL=0，CPHA=1）</p><p>（3）空闲电平高电平，下降沿取数（CPOL=1，CPHA=0）</p><p>（4）空闲电平高电平，上升沿取数（CPOL=1，CPHA=1）</p><br><p><strong>7、画一个CPOL=1和CPHA=0时的数据/时钟时序图。</strong></p><br><p><strong>8、画SPI_send1的流程图。</strong></p><br><p><strong>9、IIC是什么通信方式？</strong></p><p>IIC：集成电路互联总线，采用双向2线制串行数据传输方式。</p><br><p><strong>10、IIC主要用于哪里通信？</strong></p><p>主要用于同一电路板内各集成电路模块之间的连接</p><br><p><strong>11、IIC通信需要有几根线，是哪几种线？</strong></p><p>两根线：数据线、时钟线。</p><br><p><strong>12、IIC的寻址过程是怎么操作的？</strong> </p><p>I2C总线采用了独特的寻址约定，规定了起始信号后的第一个字节为寻址字节，用来寻址被控器件，并规定数据传送方向。<br>具体的寻址过程为：主控器发送起始信号后，立即发送寻址字节，这时总线上的所有器件都将寻址字节中的7位地址与自己器件地址比较。如果两者相同，则该器件认为被主控器寻址，并发送应答信号，被控器根据数据方向位确定自身是作为发送器还是接收器。</p><br><h2 id="4-1"><a href="#4-1" class="headerlink" title="4/1"></a>4/1</h2><p><strong>1、TSI模块是干什么用的？</strong></p><p>触摸感应输入模块TSI，可用于基于接近感应的人机交互设备的设计，实现操作人员与电气设备的隔离，避免了对设备的直接操作，也使得设备损坏的概率降低，从而减少了维护成本。</p><br><p><strong>2、TSI是通过什么方式识别触摸的？</strong></p><p>根据电子学的知识可知，未接地的电极与地之间存在电容。<br>人体可以当作是一个接地面，当有人体接近电极板时，等效地增大了电极与地之间的有效面积，使电极板电容值增大。</p><p>TSI模块的内部机制可以实现对电极电容值的检测，并且可以设定触发检测事件的阈值。当检测到电容值大于设定阈值时，TSI的触发标志位将置位，并可激活发出中断请求，从而实现了触摸感应事件的响应。</p><br><p><strong>3、TSI是通过什么方式测量电容大小的？</strong> </p><p>TSI模块内部具有两个电流源对外接电极进行充放电，在电极板上产生三角波信号，其频率随电极电容变化而变化，当电极电容增大时，三角波信号的频率减小，周期变大。<br>TSI模块以一个内部振荡器产生的时钟信号为参考节拍，对电极上的三角波电压信号的周期进行测量计数，当三角波电压信号周期增大时，对应计数值亦会增大。</p><br><p><strong>4、嵌入式实时操作系统是什么？</strong></p><p>嵌入式操作系统（Embedded Operation System，EOS）是一种工作在嵌入式计算机上的系统软件。一般情况下，它嵌入到微控制器（Microcontroller，MCU）、应用处理器（Application Processor）或其他存储载体中。<br>它有一般操作系统最基本的功能，负责嵌入式系统的软/硬件资源的分配、任务调度、同步机制、中断处理等功能。</p><br><p><strong>5、RTOS的基本结构包括哪些？</strong></p><p>从结构来看，一般情况下，RTOS内核表现为微内核（Micro Kernel）结构，将核心功能（如任务管理、任务调度、任务通信、中断处理）放在内核中，而将那些不是必需的功能和服务（如存储管理、设备管理、网络通信、文件系统等）作为内核之上可配置的部分。</p><br><p><strong>6、RTOS的基本功能有哪些？</strong></p><p>任务管理与调度、任务间的通信与同步、存储管理、时间管理、中断处理等。</p><br><p><strong>7、RTOS调度的基本单位是什么？它有那几种状态？</strong></p><p>RTOS调度的基本单位就是任务。</p><br><p><strong>8、MQX的任务间通信和同步主要机制包括哪些？</strong></p><p>MQX的任务间通信和同步主要机制有消息、事件、信号量等。</p><br><p><strong>9、整个系统的时间基准是什么？</strong></p><p>RTOS需要一个硬件定时器来产生需要的“滴答”中断，作为整个系统的时间基准，这个时间基准是系统调度的基础。滴答中断也是系统定时服务的基础，生成系统各种格式的时间。</p><br><p><strong>10、任务是什么？</strong></p><p>在RTOS下，系统把一个复杂的嵌入式应用工程按一定规则分解成一个个功能清晰的小工程，然后设定各个小工程的运行规则，交给RTOS管理，这就是基于RTOS编程的基本思想。这一个个的小工程被称之为任务（Task）。</p><br><p><strong>11、死锁产生的必要条件是哪些？</strong></p><p>死锁产生的必要条件有四个，即:<br>资源的互斥访问<br>资源的不可抢占<br>资源的请求保持<br>任务的循环等待</p><br><p><strong>12、任务间通信的方式主要有哪些？</strong> </p><p>任务间通信的方式主要有事件、信号量、消息等。</p><br><h2 id="Arduino用LED加7数码管译码器的程序。"><a href="#Arduino用LED加7数码管译码器的程序。" class="headerlink" title="Arduino用LED加7数码管译码器的程序。"></a>Arduino用LED加7数码管译码器的程序。</h2><p>大家先理解理解，以后作为作业让大家回答。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//数据编码c和位编码j的确定下,一位的显示</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LEDShow1</span><span class="params">(unsigned <span class="keyword">char</span> c,<span class="keyword">int</span> j)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> <span class="keyword">int</span> i;</span><br><span class="line"> <span class="keyword">if</span>(j&gt;<span class="number">3</span>) j=<span class="number">0</span>;<span class="comment">//位线是否越界</span></span><br><span class="line"> <span class="comment">//数据上线</span></span><br><span class="line"> <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)</span><br><span class="line"> &#123;</span><br><span class="line">  digitalWrite(LEDData[i],(c&gt;&gt;i)&amp;<span class="number">0x01</span>);<span class="comment">//c为所显示值;低4位为数据，高1位为小数点</span></span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">//位选线</span></span><br><span class="line"> <span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;<span class="number">2</span>;i++)</span><br><span class="line"> &#123;</span><br><span class="line">  digitalWrite(LEDCS[i], (j&gt;&gt;i)&amp;<span class="number">0x01</span>);<span class="comment">//2位;j为所选位</span></span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;3-4&quot;&gt;&lt;a href=&quot;#3-4&quot; class=&quot;headerlink&quot; title=&quot;3/4&quot;&gt;&lt;/a&gt;3/4&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;1.用直白的话,概述下列的函数的实现过程,并重点解释temp = (c&amp;gt;&amp;gt;j) &amp;amp; 0x01;g</summary>
      
    
    
    
    <category term="笔记" scheme="https://fish-on-net.github.io/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="嵌入式应用" scheme="https://fish-on-net.github.io/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%BA%94%E7%94%A8/"/>
    
  </entry>
  
  <entry>
    <title>example</title>
    <link href="https://fish-on-net.github.io/june/2000-01-01-example/"/>
    <id>https://fish-on-net.github.io/june/2000-01-01-example/</id>
    <published>1999-12-31T16:00:00.000Z</published>
    <updated>2022-10-20T12:22:48.185Z</updated>
    
    <content type="html"><![CDATA[<p>this is an example </p><p>it has no meaning</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;this is an example &lt;/p&gt;
&lt;p&gt;it has no meaning&lt;/p&gt;
</summary>
      
    
    
    
    
  </entry>
  
</feed>
